"""
Semantic PAPL Parser
Extracts structured data from PAPL .docx documents

Outputs:
- pricing_data.json: Support items, prices, categories
- business_rules.yaml: Claiming rules, conditions, logic
- guidance.md: Policy text, explanations, requirements
"""

from docx import Document
import json
import yaml
from typing import Dict, List, Any, Tuple
import re
from datetime import datetime


class PAPLParser:
    """
    Parse PAPL documents into structured components
    
    Philosophy: PAPL contains three types of content:
    1. Pricing Data - Tables with support items and prices
    2. Business Rules - Conditions, thresholds, requirements
    3. Guidance - Explanatory text, policy context
    """
    
    def __init__(self):
        self.pricing_keywords = [
            'price', 'rate', 'cost', 'fee', 'charge', 'amount',
            'support item', 'support category', 'registration group'
        ]
        
        self.rule_keywords = [
            'must', 'should', 'shall', 'may not', 'required', 'mandatory',
            'condition', 'threshold', 'limit', 'maximum', 'minimum',
            'claiming', 'quote', 'evidence', 'approval'
        ]
        
        self.guidance_keywords = [
            'guidance', 'note', 'example', 'information', 'consider',
            'background', 'context', 'purpose', 'overview'
        ]
    
    def parse(self, docx_path_or_file) -> Dict[str, Any]:
        """
        Parse PAPL document into structured components
        
        Args:
            docx_path_or_file: Path to .docx or file-like object
        
        Returns:
            Dict with 'pricing_data', 'business_rules', 'guidance', 'metadata'
        """
        doc = Document(docx_path_or_file)
        
        # Extract all content with metadata
        paragraphs = self._extract_paragraphs(doc)
        tables = self._extract_tables(doc)
        
        # Classify and structure content
        pricing_data = self._extract_pricing_data(tables, paragraphs)
        business_rules = self._extract_business_rules(paragraphs, tables)
        guidance = self._extract_guidance(paragraphs)
        
        # Generate metadata
        metadata = self._generate_metadata(doc, paragraphs, tables)
        
        return {
            'pricing_data': pricing_data,
            'business_rules': business_rules,
            'guidance': guidance,
            'metadata': metadata,
            'raw_tables': tables,
            'raw_paragraphs': paragraphs
        }
    
    def _extract_paragraphs(self, doc: Document) -> List[Dict[str, Any]]:
        """Extract paragraphs with metadata"""
        paragraphs = []
        for i, para in enumerate(doc.paragraphs):
            if not para.text.strip():
                continue
            
            paragraphs.append({
                'index': i,
                'text': para.text.strip(),
                'style': para.style.name if para.style else 'Normal',
                'is_heading': 'Heading' in (para.style.name if para.style else ''),
                'level': self._get_heading_level(para.style.name if para.style else '')
            })
        
        return paragraphs
    
    def _extract_tables(self, doc: Document) -> List[Dict[str, Any]]:
        """Extract tables with full data"""
        tables = []
        for i, table in enumerate(doc.tables):
            rows = []
            for row in table.rows:
                cells = [cell.text.strip() for cell in row.cells]
                rows.append(cells)
            
            if rows:
                tables.append({
                    'index': i,
                    'rows': len(rows),
                    'cols': len(rows[0]) if rows else 0,
                    'data': rows,
                    'header': rows[0] if rows else [],
                    'body': rows[1:] if len(rows) > 1 else []
                })
        
        return tables
    
    def _extract_pricing_data(self, tables: List[Dict], paragraphs: List[Dict]) -> Dict[str, Any]:
        """Extract pricing tables and related data"""
        pricing_tables = []
        
        for table in tables:
            # Check if table contains pricing data
            header = ' '.join(table['header']).lower()
            is_pricing = any(keyword in header for keyword in ['price', 'rate', 'amount', 'support item'])
            
            if is_pricing:
                # Parse pricing table
                pricing_items = []
                for row in table['body']:
                    if len(row) >= 2:  # At least item name and price
                        pricing_items.append({
                            'row_data': row,
                            'item_name': row[0] if len(row) > 0 else '',
                            'price': self._extract_price(row),
                            'category': self._extract_category(row),
                            'metadata': {
                                'row_length': len(row),
                                'all_cells': row
                            }
                        })
                
                pricing_tables.append({
                    'table_index': table['index'],
                    'header': table['header'],
                    'dimensions': {'rows': table['rows'], 'cols': table['cols']},
                    'items': pricing_items,
                    'total_items': len(pricing_items)
                })
        
        return {
            'tables': pricing_tables,
            'total_pricing_tables': len(pricing_tables),
            'total_items': sum(t['total_items'] for t in pricing_tables)
        }
    
    def _extract_business_rules(self, paragraphs: List[Dict], tables: List[Dict]) -> Dict[str, Any]:
        """Extract business rules and conditions"""
        rules = []
        
        for para in paragraphs:
            text_lower = para['text'].lower()
            
            # Check if paragraph contains rule language
            has_rule_keyword = any(keyword in text_lower for keyword in self.rule_keywords)
            
            if has_rule_keyword and len(para['text']) > 50:  # Substantial rule text
                # Extract rule components
                rule = {
                    'text': para['text'],
                    'paragraph_index': para['index'],
                    'style': para['style'],
                    'type': self._classify_rule_type(para['text']),
                    'conditions': self._extract_conditions(para['text']),
                    'entities': self._extract_entities(para['text']),
                    'priority': self._assess_rule_priority(para['text'])
                }
                rules.append(rule)
        
        return {
            'rules': rules,
            'total_rules': len(rules),
            'by_type': self._group_rules_by_type(rules),
            'high_priority': [r for r in rules if r['priority'] == 'high']
        }
    
    def _extract_guidance(self, paragraphs: List[Dict]) -> Dict[str, Any]:
        """Extract guidance and explanatory text"""
        guidance_sections = []
        current_section = None
        
        for para in paragraphs:
            # Start new section on headings
            if para['is_heading']:
                if current_section:
                    guidance_sections.append(current_section)
                current_section = {
                    'heading': para['text'],
                    'level': para['level'],
                    'paragraphs': []
                }
            elif current_section and not self._is_rule_or_pricing(para['text']):
                current_section['paragraphs'].append({
                    'text': para['text'],
                    'style': para['style']
                })
        
        if current_section:
            guidance_sections.append(current_section)
        
        # Generate markdown
        markdown = self._sections_to_markdown(guidance_sections)
        
        return {
            'sections': guidance_sections,
            'total_sections': len(guidance_sections),
            'markdown': markdown,
            'word_count': sum(len(p['text'].split()) for s in guidance_sections for p in s['paragraphs'])
        }
    
    def _generate_metadata(self, doc: Document, paragraphs: List, tables: List) -> Dict[str, Any]:
        """Generate document metadata"""
        return {
            'parsed_at': datetime.now().isoformat(),
            'total_paragraphs': len(paragraphs),
            'total_tables': len(tables),
            'total_words': sum(len(p['text'].split()) for p in paragraphs),
            'headings': [p['text'] for p in paragraphs if p['is_heading']],
            'document_structure': {
                'sections': len([p for p in paragraphs if p['is_heading']]),
                'pricing_content': 'detected',
                'rules_content': 'detected',
                'guidance_content': 'detected'
            }
        }
    
    # ===== Helper Functions =====
    
    def _get_heading_level(self, style_name: str) -> int:
        """Extract heading level from style name"""
        if 'Heading' in style_name:
            try:
                return int(re.search(r'\d+', style_name).group())
            except:
                return 1
        return 0
    
    def _extract_price(self, row: List[str]) -> str:
        """Extract price from row"""
        for cell in row:
            if '$' in cell or 'price' in cell.lower():
                # Extract just the price value
                match = re.search(r'\$[\d,]+\.?\d*', cell)
                if match:
                    return match.group()
        return ''
    
    def _extract_category(self, row: List[str]) -> str:
        """Extract category from row"""
        # Look for category indicators
        for cell in row:
            if any(term in cell.lower() for term in ['category', 'group', 'class']):
                return cell
        return ''
    
    def _classify_rule_type(self, text: str) -> str:
        """Classify type of business rule"""
        text_lower = text.lower()
        
        if 'claim' in text_lower or 'invoice' in text_lower:
            return 'claiming_rule'
        elif 'quote' in text_lower or 'quotation' in text_lower:
            return 'quoting_rule'
        elif 'evidence' in text_lower or 'documentation' in text_lower:
            return 'evidence_rule'
        elif 'approval' in text_lower or 'authorisation' in text_lower:
            return 'approval_rule'
        elif any(term in text_lower for term in ['must', 'shall', 'required', 'mandatory']):
            return 'requirement'
        elif any(term in text_lower for term in ['may', 'can', 'optional']):
            return 'permission'
        else:
            return 'general_rule'
    
    def _extract_conditions(self, text: str) -> List[str]:
        """Extract conditions from rule text"""
        conditions = []
        
        # Look for conditional phrases
        condition_patterns = [
            r'if .+?,',
            r'where .+?,',
            r'when .+?,',
            r'provided that .+?[.,]'
        ]
        
        for pattern in condition_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            conditions.extend(matches)
        
        return conditions
    
    def _extract_entities(self, text: str) -> Dict[str, List[str]]:
        """Extract key entities from text"""
        entities = {
            'amounts': re.findall(r'\$[\d,]+\.?\d*', text),
            'percentages': re.findall(r'\d+\.?\d*%', text),
            'dates': re.findall(r'\d{1,2}[-/]\d{1,2}[-/]\d{2,4}', text),
            'durations': re.findall(r'\d+\s+(?:day|week|month|year)s?', text, re.IGNORECASE)
        }
        return {k: v for k, v in entities.items() if v}
    
    def _assess_rule_priority(self, text: str) -> str:
        """Assess priority/importance of rule"""
        text_lower = text.lower()
        
        high_priority_terms = ['must', 'shall', 'required', 'mandatory', 'obligation']
        medium_priority_terms = ['should', 'recommended', 'expected']
        
        if any(term in text_lower for term in high_priority_terms):
            return 'high'
        elif any(term in text_lower for term in medium_priority_terms):
            return 'medium'
        else:
            return 'low'
    
    def _group_rules_by_type(self, rules: List[Dict]) -> Dict[str, int]:
        """Group rules by type and count"""
        type_counts = {}
        for rule in rules:
            rule_type = rule['type']
            type_counts[rule_type] = type_counts.get(rule_type, 0) + 1
        return type_counts
    
    def _is_rule_or_pricing(self, text: str) -> bool:
        """Check if text is likely a rule or pricing content"""
        text_lower = text.lower()
        return (
            any(keyword in text_lower for keyword in self.rule_keywords) or
            any(keyword in text_lower for keyword in self.pricing_keywords) or
            '$' in text
        )
    
    def _sections_to_markdown(self, sections: List[Dict]) -> str:
        """Convert sections to markdown"""
        md_lines = []
        
        for section in sections:
            # Add heading
            heading_prefix = '#' * (section['level'] if section['level'] > 0 else 1)
            md_lines.append(f"{heading_prefix} {section['heading']}\n")
            
            # Add paragraphs
            for para in section['paragraphs']:
                md_lines.append(f"{para['text']}\n")
            
            md_lines.append("")  # Blank line between sections
        
        return '\n'.join(md_lines)
    
    # ===== Export Functions =====
    
    def export_to_json(self, parsed_data: Dict[str, Any]) -> str:
        """Export pricing data to JSON"""
        export_data = {
            'pricing_data': parsed_data['pricing_data'],
            'metadata': parsed_data['metadata']
        }
        return json.dumps(export_data, indent=2)
    
    def export_to_yaml(self, parsed_data: Dict[str, Any]) -> str:
        """Export business rules to YAML"""
        export_data = {
            'business_rules': parsed_data['business_rules'],
            'metadata': {
                'parsed_at': parsed_data['metadata']['parsed_at'],
                'total_rules': parsed_data['business_rules']['total_rules']
            }
        }
        return yaml.dump(export_data, default_flow_style=False, sort_keys=False)
    
    def export_to_markdown(self, parsed_data: Dict[str, Any]) -> str:
        """Export guidance to Markdown"""
        return parsed_data['guidance']['markdown']


# Example usage
if __name__ == "__main__":
    parser = PAPLParser()
    
    # Parse a PAPL document
    # result = parser.parse('PAPL_2024Q1.docx')
    
    # Export components
    # json_output = parser.export_to_json(result)
    # yaml_output = parser.export_to_yaml(result)
    # md_output = parser.export_to_markdown(result)
    
    print("PAPL Parser ready!")
